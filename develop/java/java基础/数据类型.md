##### 理解内部类

- 内部类的作用？

  - 每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得**多继承**的解决方案变得完整（栗子如下：）

    ```java
    class WithInner {
        class Inner{
             
        }
    }
    class InheritInner extends WithInner.Inner {
          
        // InheritInner() 是不能通过编译的，一定要加上形参
        InheritInner(WithInner wi) {
            wi.super(); //必须有这句调用
        }
      
        public static void main(String[] args) {
            WithInner wi = new WithInner();
            InheritInner obj = new InheritInner(wi);
        }
    }
    ```

  - 方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏

- 成员内部类**可以无条件访问外部类的成员？

  > 会，编译器在进行编译的时候，会将成员内部类**单独**编译成一个字节码文件，``Outter.java``的代码实例如下：

  ```java
  public class Outter {
      private Inner inner = null;
      public Outter() {  
      } 
      public Inner getInnerInstance() {
          if(inner == null)
              inner = new Inner();
          return inner;
      } 
      protected class Inner {
          public Inner() {    
          }
      }
  }
  ```

  编译后：``Outter$inner.class`` 和 ``Outter.class``
  **反编译** ``Outter$inner.class``：

  ```java
  E:\Workspace\Test\bin\com\cxh\test2>javap -v Outter$Inner
  Compiled from "Outter.java"
  public class com.cxh.test2.Outter$Inner extends java.lang.Object
    SourceFile: "Outter.java"
    InnerClass:
     #24= #1 of #22; //Inner=class com/cxh/test2/Outter$Inner of class com/cxh/tes
  t2/Outter
    minor version: 0
    major version: 50
    Constant pool:
  const #1 = class        #2;     //  com/cxh/test2/Outter$Inner
  const #2 = Asciz        com/cxh/test2/Outter$Inner;
  const #3 = class        #4;     //  java/lang/Object
  const #4 = Asciz        java/lang/Object;
  const #5 = Asciz        this$0;
  const #6 = Asciz        Lcom/cxh/test2/Outter;;
  const #7 = Asciz        <init>;
  const #8 = Asciz        (Lcom/cxh/test2/Outter;)V;
  const #9 = Asciz        Code;
  const #10 = Field       #1.#11; //  com/cxh/test2/Outter$Inner.this$0:Lcom/cxh/t
  est2/Outter;
  const #11 = NameAndType #5:#6;//  this$0:Lcom/cxh/test2/Outter;
  const #12 = Method      #3.#13; //  java/lang/Object."<init>":()V
  const #13 = NameAndType #7:#14;//  "<init>":()V
  const #14 = Asciz       ()V;
  const #15 = Asciz       LineNumberTable;
  const #16 = Asciz       LocalVariableTable;
  const #17 = Asciz       this;
  const #18 = Asciz       Lcom/cxh/test2/Outter$Inner;;
  const #19 = Asciz       SourceFile;
  const #20 = Asciz       Outter.java;
  const #21 = Asciz       InnerClasses;
  const #22 = class       #23;    //  com/cxh/test2/Outter
  const #23 = Asciz       com/cxh/test2/Outter;
  const #24 = Asciz       Inner;
   
  {
  final com.cxh.test2.Outter this$0;
   
  public com.cxh.test2.Outter$Inner(com.cxh.test2.Outter);
    Code:
     Stack=2, Locals=2, Args_size=2
     0:   aload_0
     1:   aload_1
     2:   putfield        #10; //Field this$0:Lcom/cxh/test2/Outter;
     5:   aload_0
     6:   invokespecial   #12; //Method java/lang/Object."<init>":()V
     9:   return
    LineNumberTable:
     line 16: 0
     line 18: 9
   
    LocalVariableTable:
     Start  Length  Slot  Name   Signature
     0      10      0    this       Lcom/cxh/test2/Outter$Inner;
   
   
  }
  ```

  - line38：``final com.cxh.test2.Outter this$0;`` 

    > 成员内部类中保存了一个外部类的引用 ``this$0``

  - line40：``public com.cxh.test2.Outter$Inner(com.cxh.test2.Outter); `` 

    > ​    从这里可以看出，虽然我们在定义的内部类的构造器是无参构造器，编译器还是会默认添加一个参数，该参数的类型为指向外部类对象的一个引用，所以成员内部类中的``Outter this&0`` 指针便指向了外部类对象，因此可以在成员内部类中随意访问外部类的成员。
    >
    > ​    从这里也间接说明了成员内部类是依赖于外部类的，如果没有创建外部类mai的对象，则无法对``Outter this&0``引用进行初始化赋值，也就无法创建成员内部类的对象了。

- 为什么局部内部类和匿名内部类只能访问局部final变量

  > 从``JDK 1.8``开始，会默认给这两种内部类访问的field 加上final(隐式地)，所以你可能会在编译器中看到可以访问没有加final的变量，只有你去修改它时，编译器才会报错

  >如下代码，当test()方法执行完成后，变量 a 的生命周期就结束了，但是new出来的内部类Thread对象的生命周期很**可能还没有结束**，所以避免访问不到a 的情况，Java 采用了 **复制**的手段

  ```java
  public class Test {
      public static void main(String[] args)  {
           
      }
      public void test(final int b) {
          // 成员变量
          final int a = 10;
          new Thread(){
              public void run() {
                  System.out.println(a);
                  System.out.println(b);
              };
          }.start();
      }
  }
  
  // 编译后
  Compiled from "Test.java"
  class com.corejava.basejdk.Test$1 extends java.lang.Thread {
    final int val$b;
  
    final com.corejava.basejdk.Test this$0;
  
    com.corejava.basejdk.Test$1(com.corejava.basejdk.Test, int);
      Code:
         0: aload_0
         1: aload_1
         2: putfield      #1                  // Field this$0:Lcom/corejava/basejdk/Test;
         5: aload_0
         6: iload_2
         7: putfield      #2                  // Field val$b:I
        10: aload_0
        11: invokespecial #3                  // Method java/lang/Thread."<init>":()V
        14: return
  
    public void run();
      Code:
         0: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;
         3: bipush        10
         5: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V
         8: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;
        11: aload_0
        12: getfield      #2                  // Field val$b:I
        15: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V
        18: return
  }
  ```

  - line20：``  final int val$b;`` 和 line24 ``com.corejava.basejdk.Test$1(com.corejava.basejdk.Test, int);``
    可以看出 对于编译时不能确认的变量b，编译器复制了一份``val$b``，将其作为构造器的参数在构造时初始化。

  - line39：``3: bipush    10``可以看出编译器将操作数10压栈，表示使用的是一个本地局部变量

    > 如果这个变量的值在编译期间可以确定，则编译器默认会在匿名内部类（局部内部类）的常量池中添加一个内容相等的字面量或直接将相应的字节码嵌入到执行字节码中
    >
    > 可以看出匿名内部类使用的变量是另一个局部变量，只不过值和方法中局部变量的值相等，因此和方法中的局部变量完全独立开

  - 可以看出，编译时进栈后，如果变量a还能被修改，就会出现不一致的问题，使用final修饰变量a就能避免a再被改变。（这是由于匿名内部类中的变量的声明周期导致）

